datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/// Rating given by a volunteer to an event (after it is over)
model EventRating {
  id          String   @id @default(cuid())
  eventId     String
  volunteerId String
  rating      Int /// 1-5
  comment     String?
  createdAt   DateTime @default(now())

  event     Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  volunteer Volunteer @relation(fields: [volunteerId], references: [id], onDelete: Cascade)

  @@unique([eventId, volunteerId])
  @@index([eventId])
  @@index([volunteerId])
}

/// Many-to-many style link between Organization and User for membership/admin access
model OrganizationMember {
  id             String @id @default(cuid())
  organizationId String
  userId         String

  createdAt DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                      String                    @id @default(cuid())
  name                    String?
  email                   String                    @unique
  emailVerified           DateTime?
  image                   String?
  accounts                Account[]
  volunteer               Volunteer?
  role                    Role                      @default(VOLUNTEER)
  profileComplete         Boolean                   @default(false)
  hashedPassword          String?
  notifications           NotificationPreference?
  organizationMemberships OrganizationMember[]
  /// Backref: messages authored by this user in event chats
  chatMessages            ChatMessage[]
  /// Backref: join requests created by this user
  joinRequests            OrganizationJoinRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

enum Role {
  VOLUNTEER
  ORGANIZATION
}

/// Transportation options for volunteers
enum TransportMode {
  PROVIDE_OTHERS /// can provide rides for self and others (carpool)
  SELF_ONLY /// can drive self only
  RIDESHARE /// accept CampusReach-provided rideshare
}

/// Organizations that can be created on Campus Reach
model Organization {
  id       String  @id @default(cuid())
  name     String
  slug     String? @unique
  email    String?
  industry String?
  website  String?

  // Profile fields
  avatarUrl                    String?
  logoUrl                      String?
  description                  String?
  mission                      String?
  contactName                  String?
  contactEmail                 String?
  contactPhone                 String?
  categories                   String[]
  twitter                      String?
  instagram                    String?
  facebook                     String?
  linkedin                     String?
  // Preferences
  timezone                     String? // e.g., "America/New_York"
  locale                       String? // e.g., "en-US"
  defaultEventLocationTemplate String?
  defaultTimeCommitmentHours   Int?
  defaultVolunteersNeeded      Int?

  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt
  /// Events hosted by this organization
  events    Event[]
  /// Members (users) that can manage this organization
  members   OrganizationMember[]

  /// Pending/approved/declined join requests
  joinRequests OrganizationJoinRequest[]

  /// Additional contacts
  contacts OrganizationContact[]

  /// Signup intents that target this organization
  signupIntents SignupIntent[]
}

model OrganizationContact {
  id             String       @id @default(cuid())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String
  name           String
  email          String?
  phone          String?
  role           String?
  createdAt      DateTime     @default(now())
}

model Volunteer {
  id     String @id @default(cuid())
  userId String @unique

  // Public profile
  slug String? @unique

  // Profile fields
  firstName      String
  lastName       String
  pronouns       String?
  school         String?
  major          String?
  graduationDate DateTime?
  phone          String?

  // Transportation preferences
  transportMode  TransportMode @default(SELF_ONLY)
  radiusMiles    Int           @default(10)
  transportNotes String?

  // Goals
  weeklyGoalHours Int?

  // Relations
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  signups     EventSignup[]
  timeEntries TimeEntry[]
  ratings     EventRating[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// Events created by organizations
model Event {
  id             String        @id @default(cuid())
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  // Core fields
  title               String
  shortDescription    String?
  startsAt            DateTime
  endsAt              DateTime?
  location            String    @default("TBD")
  volunteersNeeded    Int
  notes               String?
  timeCommitmentHours Int?

  // Optional, stored as scalar lists
  attachments String[] // e.g. URLs to uploaded files
  specialties String[] // desired specialties/majors

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  // Signups
  signups     EventSignup[]
  timeEntries TimeEntry[]
  /// Group chat for this event (one chat per event)
  groupChat   GroupChat?
  /// Backref for legacy messages during migration
  messages    ChatMessage[]
  ratings     EventRating[]
}

/// A volunteer signing up for an event
model EventSignup {
  id          String       @id @default(cuid())
  eventId     String
  volunteerId String
  status      SignupStatus @default(CONFIRMED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event     Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  volunteer Volunteer @relation(fields: [volunteerId], references: [id], onDelete: Cascade)

  @@unique([eventId, volunteerId])
}

enum SignupStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

/// Status of a join request to an organization
enum JoinStatus {
  PENDING
  APPROVED
  DECLINED
}

/// Signup intent kinds used to drive OAuth flow
enum SignupIntentKind {
  ORG_CREATE
  ORG_JOIN
  USER_SIGNUP
}

/// Message types within an event group chat
enum ChatMessageKind {
  MESSAGE /// regular user/org message
  ANNOUNCEMENT /// organization announcement
}

/// One group chat per event
model GroupChat {
  id        String   @id @default(cuid())
  eventId   String   @unique
  createdAt DateTime @default(now())

  event    Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  messages ChatMessage[]
}

/// Author type for messages
enum MessageAuthorType {
  USER
  SYSTEM
}

/// Group chat messages
model ChatMessage {
  id          String            @id @default(cuid())
  groupChatId String?
  eventId     String?
  userId      String?
  authorType  MessageAuthorType @default(USER)
  kind        ChatMessageKind   @default(MESSAGE)
  body        String
  createdAt   DateTime          @default(now())

  groupChat GroupChat? @relation(fields: [groupChatId], references: [id], onDelete: Cascade)
  event     Event?     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      User?      @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([groupChatId, createdAt])
  @@index([eventId, createdAt])
}

/// A user's request to join an existing organization
model OrganizationJoinRequest {
  id             String     @id @default(cuid())
  organizationId String
  userId         String
  status         JoinStatus @default(PENDING)
  message        String?
  createdAt      DateTime   @default(now())
  decidedAt      DateTime?

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId, status])
  @@index([organizationId, status, createdAt])
}

/// Short-lived state to persist signup intent across OAuth redirects
model SignupIntent {
  id             String            @id @default(cuid())
  token          String            @unique
  kind           SignupIntentKind
  organizationId String?
  organization   Organization?     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String?           // existing user initiating the flow (optional)
  email          String?           // prefilled or expected email (optional)
  metadata       Json?             // extra context if needed
  createdAt      DateTime          @default(now())
  expiresAt      DateTime
  usedAt         DateTime?

  @@index([organizationId, kind])
  @@index([email, kind])
}

// Removed Resource model and ResourceKind enum as unused

/// Per-user notification preferences
model NotificationPreference {
  userId       String  @id
  emailUpdates Boolean @default(true)
  pushEnabled  Boolean @default(false)
  weeklyDigest Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// Logged hours for a volunteer (optionally tied to an event)
model TimeEntry {
  id          String   @id @default(cuid())
  volunteerId String
  eventId     String?
  date        DateTime // when the volunteering occurred
  hours       Decimal // number of hours (e.g., 1.5)
  notes       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  volunteer Volunteer @relation(fields: [volunteerId], references: [id], onDelete: Cascade)
  event     Event?    @relation(fields: [eventId], references: [id], onDelete: SetNull)

  @@index([volunteerId, date])
}
